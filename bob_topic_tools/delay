#!/usr/bin/env python3
# 
# Copyright 2023 BobRos
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
import rclpy
from rclpy.node import Node
from rcl_interfaces.msg import ParameterDescriptor
from std_msgs.msg import String
from rclpy.duration import Duration

class DelayNode(Node):
    """
    Basic String topic delay node.
    """
    def __init__(self):
        super().__init__('delay')

        self.declare_parameter('delay_ms', 4000,
            ParameterDescriptor(description=
            'Delay time in milli seconds'))

        self.sub = self.create_subscription(
            String, 'delay_in', self.input_callback, 100)

        self.pub = self.create_publisher(
            String, 'delay_out', 100)

        self.queue = []
        self.timer = None

    def set_timer(self, delay_ms: int=None):
        """
        Set timer
        """

        delay_ms = delay_ms or self.get_parameter(
            'delay_ms').get_parameter_value().integer_value

        if self.timer:
            self.timer.cancel()

        self.timer = self.create_timer(
            delay_ms/1000, self.timer_callback)

    def input_callback(self, msg: String):
        """
        Will be called for every incoming message.
        """

        now = self.get_clock().now()
        self.queue.append((now, msg))

        # if it's the first item start the timer
        if len(self.queue) == 1: 
            self.set_timer()

    def timer_callback(self):
        """
        Will be called for every expired timer 
        and reset for next one if queue is not empty.
        """

        if len(self.queue):
            _, msg = self.queue.pop(0)
            self.pub.publish(msg)

        if len(self.queue):

            time, _ = self.queue[0]

            delay_ms = self.get_parameter(
                'delay_ms').get_parameter_value().integer_value

            i, d = divmod(delay_ms/1000, 1)
            d = Duration(seconds=int(i), nanoseconds=int(d*1000000000))
            now = self.get_clock().now()

            if time + d > now: 
                rest = time + d - now
                self.set_timer(
                    delay_ms=int(rest.nanoseconds/1000000))
            else: # already expired
                self.set_timer(delay_ms=1)

        else: # no more entries
            self.timer.cancel()

def main():
    rclpy.init(args=None)
    n = DelayNode()
    rclpy.spin(n)
    rclpy.shutdown()

if __name__ == '__main__':
    main()
